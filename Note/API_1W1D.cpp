#include <iostream>

// 윈도우 안에는 여러가지의 프로그램이 존재할 수 있다.
// 여러개의 프로그램을 구별하기 위해 고유의 ID가 존재하며 핸들이라고 부른다.
// 실제로 할당된 메모리의 소유권을 나타내는 ID라고 생각하자

// 함수 호출 규약
// 1. cdecl 함수 호출 규약
//   인자 전달 순서 : 가장 오른쪽 인자 -> 가장 왼쪽 인자
//   인자 전달 방법 : 스택 메모리 이용
//   스택 프레임 정리 : Caller(호출자)가 스택 프레임을 정리한다.
//   가변 인자 사용여부 : 사용 가능
// 2. stdcall 함수 호출 규약 --CALLBACK
//   인자 전달 순서 : 가장 오른쪽 인자 -> 가장 왼쪽 인자
//   인자 전달 방법 : 스택 메모리 이용
//   스택 프레임 정리 : Callee(피호출자)가 스택 프레임을 정리한다.
//   가변 인자 사용여부 : 사용 불가능

// 함수 포인터
// 함수도 메모리 영역(코드 영억)에 존재하며 주소를 가지고 있다.
void test()
{
    int a = 0;
};
//  자료형 (*함수 포인터 이름)(인자타입)
void (*ptrFunc)();

// 윈도우 API는 메시지 기반으로 데이터를 처리한다.
// 큐로 처리한다(순차적으로 처리)

// 핸들 - 윈도우 고유의 id 
// 직접 접근해서 작업을 하게 되면 용량문제나 주소를 침범해서
// 데이터 변조나 다른 프로그램 주소에 접근할수도있다.
// 위의 문제를 막기위해 프로그램 창(윈도우)마다 숫자(핸들)을 부여하여 접근한다.

//윈도우 좌표계
// 흔히 아는 수학의 데카르트 좌표계와는 다르다
// y좌표가 아래로 내려갈수록 값이 커진다

//HINSTANCE - 프로그램 자체의 핸들이며 구분짓는 ID 핸들
//HWND - 윈도우 핸들 -> 윈도우의 옵션(크기, 작업표시 등)을 저장하며 접근할수있게 해주는 핸들
//HDC - 화면에 출력에 필요한 정보를 가지는 데이터 구조, 
//      좌표, 색, 굵기 등 필요한 정보를 담고있는 핸들


// stock 오브젝트
// 기본으로 생성되는 펜(검은색)과 브러쉬(하얀색)

// selectobject(HDC, HGDIOBJ);
// 위 함수의 반환값은 HGDIOBJ로 기존에 쓰던 스톡오브젝트

// 메모리 단편화
// ㄴ 

int main()
{
    ptrFunc = test;
    //test함수를 찾아간다.
    ptrFunc();

    std::cout << "Hello World!\n";
}

